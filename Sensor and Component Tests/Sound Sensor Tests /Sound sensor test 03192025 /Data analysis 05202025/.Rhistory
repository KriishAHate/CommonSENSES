)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 600  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 700  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 800  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 900  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 1000  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# ===============================
# R Script: Binned dB - Open vs Big Hole
# ===============================
# This script bins decibel (dB) values from Sensor1 and Sensor3,
# computes averages within each bin, and generates a correlation plot
# between the open and large hole (1 inch) configurations.
# ------------------------------
# Set bin interval (in milliseconds)
# ------------------------------
bin_interval <- 100  # Change as needed
# ------------------------------
# Get time range
# ------------------------------
start_time <- min(data$Timestamp)
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = FALSE)
# ===============================
# R Script: Sound Sensor Analysis
# ===============================
# This script reads sound sensor data from a TXT file,
# converts raw ADC values to dB, plots a correlation graph with a best-fit line,
# and computes linear regression parameters, displaying them on the graph.
# Sensor 1 (open) 2 (small hole 6mm) 3 (large hole 1 inch)
# ------------------------------
# Load necessary libraries
# ------------------------------
# The ggplot2 library is used to create visualizations
library(ggplot2)
# ------------------------------
# Read the data from the TXT file
# ------------------------------
# Define the file path for the dataset
file_path <- "LOG (3 sensor test).TXT"  # Ensure this file is in the working directory
# Read the file into a data frame
# read.table() reads a comma-separated file without a header
# The resulting data frame will have four columns: Timestamp, Sensor1, Sensor2, Sensor3
data <- read.table(file_path, header = FALSE, sep = ",",
col.names = c("Timestamp", "Sensor1", "Sensor2", "Sensor3"))
# ------------------------------
# Define constants
# ------------------------------
# Set the reference voltage used for ADC conversion
VREF <- 6.14
# ------------------------------
# Convert raw ADC values to dB
# ------------------------------
# Convert raw ADC values to voltage
# Formula: ( (read value) / (ADC max value) ) * voltage reference
data$Sensor1_Voltage <- ((data$Sensor1) / (32768.0)) * VREF
data$Sensor2_Voltage <- ((data$Sensor2) / (32768.0)) * VREF
data$Sensor3_Voltage <- ((data$Sensor3) / (32768.0)) * VREF
# ------------------------------
# Convert voltage to decibels (dB)
# ------------------------------
# Formula: dB = Voltage * 50 (Scaling factor)
data$Sensor1_dB <- data$Sensor1_Voltage * 50.0
data$Sensor2_dB <- data$Sensor2_Voltage * 50.0
data$Sensor3_dB <- data$Sensor3_Voltage * 50.0
# ===============================
# R Script: Binned dB - Open vs Big Hole
# ===============================
# This script bins decibel (dB) values from Sensor1 and Sensor3,
# computes averages within each bin, and generates a correlation plot
# between the open and large hole (1 inch) configurations.
# ------------------------------
# Set bin interval (in milliseconds)
# ------------------------------
bin_interval <- 100  # Change as needed
# ------------------------------
# Get time range
# ------------------------------
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# ------------------------------
# Calculate number of bins (round up to cover full range)
# ------------------------------
n_bins <- ceiling((end_time - start_time) / bin_interval)
# ------------------------------
# Preallocate arrays
# ------------------------------
binned_Timestamps   <- numeric(n_bins)
binned_Sensor1_dB   <- numeric(n_bins)
binned_Sensor3_dB   <- numeric(n_bins)
# ------------------------------
# Loop to compute bin averages
# ------------------------------
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# ------------------------------
# Combine into a data frame
# ------------------------------
binned_dB_big_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor3_dB = binned_Sensor3_dB
)
# ------------------------------
# Regression and correlation analysis
# ------------------------------
model_dB_big <- lm(Sensor3_dB ~ Sensor1_dB, data = binned_dB_big_df)
slope_dB_big <- coef(model_dB_big)[2]
intercept_dB_big <- coef(model_dB_big)[1]
r_squared_dB_big <- summary(model_dB_big)$r.squared
correlation_dB_big <- sqrt(r_squared_dB_big)
regression_text_dB_big <- paste(
"Slope:", round(slope_dB_big, 3), "\n",
"Intercept:", round(intercept_dB_big, 3), "\n",
"R-squared:", round(r_squared_dB_big, 3), "\n",
"Correlation:", round(correlation_dB_big, 3)
)
text_x_dB_big <- min(binned_dB_big_df$Sensor1_dB) + 0.05 * diff(range(binned_dB_big_df$Sensor1_dB))
text_y_dB_big <- min(binned_dB_big_df$Sensor3_dB) + 0.85 * diff(range(binned_dB_big_df$Sensor3_dB))
# ------------------------------
# Plot
# ------------------------------
library(ggplot2)
plot_dB_big <- ggplot(binned_dB_big_df, aes(x = Sensor1_dB, y = Sensor3_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x_dB_big, y = text_y_dB_big, label = regression_text_dB_big, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 (Open) vs Sensor 3 (Big Hole) - dB (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 3 (dB)") +
theme_minimal()
print(plot_dB_big)
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = FALSE)
# ===============================
# R Script: Sound Sensor Analysis
# ===============================
# This script reads sound sensor data from a TXT file,
# converts raw ADC values to dB, plots a correlation graph with a best-fit line,
# and computes linear regression parameters, displaying them on the graph.
# Sensor 1 (open) 2 (small hole 6mm) 3 (large hole 1 inch)
# ------------------------------
# Load necessary libraries
# ------------------------------
# The ggplot2 library is used to create visualizations
library(ggplot2)
# ------------------------------
# Read the data from the TXT file
# ------------------------------
# Define the file path for the dataset
file_path <- "LOG (3 sensor test).TXT"  # Ensure this file is in the working directory
# Read the file into a data frame
# read.table() reads a comma-separated file without a header
# The resulting data frame will have four columns: Timestamp, Sensor1, Sensor2, Sensor3
data <- read.table(file_path, header = FALSE, sep = ",",
col.names = c("Timestamp", "Sensor1", "Sensor2", "Sensor3"))
# ------------------------------
# Define constants
# ------------------------------
# Set the reference voltage used for ADC conversion
VREF <- 6.14
# ------------------------------
# Convert raw ADC values to dB
# ------------------------------
# Convert raw ADC values to voltage
# Formula: ( (read value) / (ADC max value) ) * voltage reference
data$Sensor1_Voltage <- ((data$Sensor1) / (32768.0)) * VREF
data$Sensor2_Voltage <- ((data$Sensor2) / (32768.0)) * VREF
data$Sensor3_Voltage <- ((data$Sensor3) / (32768.0)) * VREF
# ------------------------------
# Convert voltage to decibels (dB)
# ------------------------------
# Formula: dB = Voltage * 50 (Scaling factor)
data$Sensor1_dB <- data$Sensor1_Voltage * 50.0
data$Sensor2_dB <- data$Sensor2_Voltage * 50.0
data$Sensor3_dB <- data$Sensor3_Voltage * 50.0
```{r data processing and conversion, include=TRUE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = FALSE)
# ------------------------------
# Load necessary libraries
# ------------------------------
# The ggplot2 library is used to create visualizations
library(ggplot2)
# ------------------------------
# Read the data from the TXT file
# ------------------------------
# Define the file path for the dataset
file_path <- "LOG (3 sensor test).TXT"  # Ensure this file is in the working directory
# Read the file into a data frame
# read.table() reads a comma-separated file without a header
# The resulting data frame will have four columns: Timestamp, Sensor1, Sensor2, Sensor3
data <- read.table(file_path, header = FALSE, sep = ",",
col.names = c("Timestamp", "Sensor1", "Sensor2", "Sensor3"))
# ------------------------------
# Define constants
# ------------------------------
# Set the reference voltage used for ADC conversion
VREF <- 6.14
# ------------------------------
# Convert raw ADC values to dB
# ------------------------------
# Convert raw ADC values to voltage
# Formula: ( (read value) / (ADC max value) ) * voltage reference
data$Sensor1_Voltage <- ((data$Sensor1) / (32768.0)) * VREF
data$Sensor2_Voltage <- ((data$Sensor2) / (32768.0)) * VREF
data$Sensor3_Voltage <- ((data$Sensor3) / (32768.0)) * VREF
# ------------------------------
# Convert voltage to decibels (dB)
# ------------------------------
# Formula: dB = Voltage * 50 (Scaling factor)
data$Sensor1_dB <- data$Sensor1_Voltage * 50.0
data$Sensor2_dB <- data$Sensor2_Voltage * 50.0
data$Sensor3_dB <- data$Sensor3_Voltage * 50.0
