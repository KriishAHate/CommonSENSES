bin_interval <- 300  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 400  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 500  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 500  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 600  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 700  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 800  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 900  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
# Set bin interval (in milliseconds)
bin_interval <- 1000  # Change as needed
# Get time range
start_time <- min(data$Timestamp)
end_time <- max(data$Timestamp)
# Calculate number of bins (round up to cover full range)
n_bins <- ceiling((end_time - start_time) / bin_interval)
# Preallocate arrays
binned_Timestamps   = numeric(n_bins)
binned_Sensor1_dB   = numeric(n_bins)
binned_Sensor2_dB   = numeric(n_bins)
binned_Sensor3_dB   = numeric(n_bins)
# Loop to compute bin averages
for (i in 1:n_bins) {
# Current bin start and end time
t_start <- start_time + (i - 1) * bin_interval
t_end   <- t_start + bin_interval
# Get data in this bin
bin_rows <- data[data$Timestamp >= t_start & data$Timestamp < t_end, ]
# Compute mean values
binned_Timestamps[i]   <- t_start
binned_Sensor1_dB[i]   <- mean(bin_rows$Sensor1_dB)
binned_Sensor2_dB[i]   <- mean(bin_rows$Sensor2_dB)
binned_Sensor3_dB[i]   <- mean(bin_rows$Sensor3_dB)
}
# Combine into a data frame
binned_df <- data.frame(
Time = binned_Timestamps,
Sensor1_dB = binned_Sensor1_dB,
Sensor2_dB = binned_Sensor2_dB,
Sensor3_dB = binned_Sensor3_dB
)
# Regression and plotting (Sensor1 vs Sensor2)
model <- lm(Sensor2_dB ~ Sensor1_dB, data = binned_df)
slope <- coef(model)[2]
intercept <- coef(model)[1]
r_squared <- summary(model)$r.squared
correlation <- sqrt(r_squared)
regression_text <- paste(
"Slope:", round(slope, 3), "\n",
"Intercept:", round(intercept, 3), "\n",
"R-squared:", round(r_squared, 3), "\n",
"Correlation:", round(correlation, 3)
)
View(binned_df)
text_x <- min(binned_df$Sensor1_dB) + 0.05 * diff(range(binned_df$Sensor1_dB))
text_y <- min(binned_df$Sensor2_dB) + 0.85 * diff(range(binned_df$Sensor2_dB))
# Plot
plot <- ggplot(binned_df, aes(x = Sensor1_dB, y = Sensor2_dB)) +
geom_point(alpha = 0.5, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
annotate("text", x = text_x, y = text_y, label = regression_text, size = 5, hjust = 0) +
ggtitle(paste("Sensor 1 vs Sensor 2 (Binned Every", bin_interval, "ms)")) +
xlab("Sensor 1 (dB)") +
ylab("Sensor 2 (dB)") +
theme_minimal()
print(plot)
